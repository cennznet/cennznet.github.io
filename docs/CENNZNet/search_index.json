[{"topic":"CENNZNet","path":"cennznet.github.io/docs/CENNZNet/CHANGELOG.md","text":"\n"},{"topic":"CENNZNet","path":"cennznet.github.io/docs/CENNZNet/README.md","text":"Readme\n\nDocumentation Structure\nConfluence Page referencehttps&#x3A;//centralitydev.atlassian.net/wiki/spaces/CNET/pages/694845844/CENNZNet+Documentation+Plan+Draft\n\nOverview\n\nCENNZNet Powered by Pl^g\n\nAddress & Account Management\n\nCENNZNet Protocols \n\nGeneric Asset\n\nAttestation\n\nCommunication\n\nSingle Sign-On/Permission\n\nSpot Exchange\n\nSmart Contract\n\nConsensus - Proof of Stake\n\nTransactions\n\nMonetary Policy\n\nStaking Token\n\nSpending Token\n\nReserve Token\n\nUser Token\n\nMigrate CENNZ to Mainnet\n\nTransaction Fees\n\nNodes\n\nValidator Node\n\nFull Node\n\nStaking\n\nReward\n\nSlash/punishment\n\nGovernance\n\nCENNZNet Development Roadmap\n\nCENNZNet SDK (SDK Team)\n\nCENNZNet Network (Nodes Team)\n\nConnecting to the Network \n\nTest Network\n\nSetting up local testnet\n\nTools & Resources\n\nWeb UI (cennznet-ui, Node Team)\n\nExplorer (CENNZScan Team)\n\nCENNZNet Client / Node Software (Node Team)\n\nCENNZNet Client in the cloud (Unfrastructure Team)\n\nCLI (cennz-cli, SDK team)\n\nSingleSource Wallet (SS Wallet team)\n\nCENNZNet Tests (Jin)\n\nTutorials\n\nCommunity\n\nCENNZNet Improvement Proposals (CIP)\n\nStack Exchange/Reddit (Check with Abby)?\n\nThe Pl^g Foundation/Centrality \n\nContributors\n\nFrequently Asked Questions\n\nGlossary\n"},{"topic":"CENNZNet","path":"cennznet.github.io/docs/CENNZNet/cennznet_network/connect.md","text":"Connect to CENNZNet Network\n\nConnect via Docker\n\nConnect via binary\n\nConnect via rUN a Node Software\n\nRefer to How to run a node on CENNZNet\n"},{"topic":"CENNZNet","path":"cennznet.github.io/docs/CENNZNet/cennznet_network/localtestnet.md","text":"Set up a Local Test Net\n\nSet up via Docker\n"},{"topic":"CENNZNet","path":"cennznet.github.io/docs/CENNZNet/cennznet_network/testnetwork.md","text":"Connect to Rimu Test Net\n\nConnect via Docker\n\nConnect via binary\n\nConnect via rUN a Node Software\n\nRefer to How to run a node on CENNZNet\n"},{"topic":"CENNZNet","path":"cennznet.github.io/docs/CENNZNet/community.md","text":"Community\n\nCENNZNet Github Repo\n\nTODO Refer to the Community Page for more ways to participate in the CENNZNet community.\n\nYou can also contact support@centrality.ai for any questions. \n"},{"topic":"CENNZNet","path":"cennznet.github.io/docs/CENNZNet/contributors.md","text":"\n"},{"topic":"CENNZNet","path":"cennznet.github.io/docs/CENNZNet/faq.md","text":"\n"},{"topic":"CENNZNet","path":"cennznet.github.io/docs/CENNZNet/foundation.md","text":"\n"},{"topic":"CENNZNet","path":"cennznet.github.io/docs/CENNZNet/glossary.md","text":"\n"},{"topic":"CENNZNet","path":"cennznet.github.io/docs/CENNZNet/index.md","text":"About This Guide\n\nThis document provides an overview of CENNZNet, a public blockchain network that is an implementation of the PL^G blockchain framework and toolkit. It captures ways in which users would want to participate in the CENNZNet network and the CENNZNet project; it introduces a series of protocols that can be leveraged to build decentralised applications (dApps), as well as tools and resources that can be used to interact with CENNZNet.\n"},{"topic":"CENNZNet","path":"cennznet.github.io/docs/CENNZNet/overview/address.md","text":"Addresses & Account Management\n\nAddress Format\n\nCENNZnet address format is based on SS58.\n\n\n\nCurrently the Generic Substrate wildcard (SS58 checksum preimage) format is used which means the address-type is always 0b00101010 (42).\n\nOnly the 35 bytes format with account public key is officially supported.\n\n\n\nCENNZNet currently uses the ed25519 public key signature system. It plans to upgrade to the schnorrkel an implementation of Schnorr signature on Ristretto, which makes multi-signature simple and efficient, and provides a Verifiable Random Function VRF.\n\nExample address:\n\nPrivate Key:\n\nText format: Alice  (Pad to 32 characters with space)\n\nHex Format: 0x416c696365202020202020202020202020202020202020202020202020202020\n\nPublic Address:\n\nSS58 Format: 5GoKvZWG5ZPYL1WUovuHW3zJBWBP5eT8CbqjdRY4Q6iMaDtZ\n\nHex Format: 2ad172a74cda4c865912c32ba0a80a57ae69abae410e5ccb59dee84e2f4432db4f5e26\n\nBreakdown:\n\nAddress type: 0x2a (42)\n\nPublic Key: 0xd172a74cda4c865912c32ba0a80a57ae69abae410e5ccb59dee84e2f4432db4f\n\nChecksum: 0x5e26 (Full hash: 0x5e2600dcf27c16cfee87964ec3f88e51318f4631601c435bd81cbdef588334949a3a16ec38ccac1d4ff69c74241d945e08434a085654cfd055e9dc708d403e02)\n\nGenerate an Account\n\nUsing mnemonic seed\n\nTODO: use cli to generate or import mnemonic seed\n\nUsing private key\n\nTODO: use cli to generate or import private key\n\nCreate new account with derived key\n\nTODO: use cli to generate a new account with already imported seed\n\nAdditional Notes\n\nThe address format is subject to change in the future release.\n\nPossible changes includes:\n\nUpgrade public key generation algorithm from ed25519 to sr25519\n\nChange address-type from generic substrate (42) to a different CENNZnet unique value\n\nSupport index based address format for compact addresses\n"},{"topic":"CENNZNet","path":"cennznet.github.io/docs/CENNZNet/overview/cennznet.md","text":"What is CENNZnet\n\nCENNZnet is a public open blockchain network that allows anyone to build decentralised applications with first-class usability, such as easy bootstrapping for new dApps and seamless onboarding for new users, by leveraging CENNZnet protocols. \n\nBlockchain 3.0\n\nBlockchain 1.0 is a Bitcoin-like value transfer network. Blockchain 2.0 is Ethereum-like smart contract network. Blockchain 3.0 is the next generation of blockchain and has the ambition to tackle scalability, interoperability and upgradability. \n\nCENNZnet is an implementation of PL^G, which has been designed to be upgradable without forking interoperable with public, private and consortium blockchains, and is more scalable. The PL^G framework uses Substrate as blockchain infrastructure. It uses WebAssembly for state-transition or runtime (aka the blockchain business logic), which is dynamic and upgradable without forking. PL^G uses Libp2p for peer discovery and communication between nodes, which is modular and also upgradable.  \n\nHow does CENNZnet work\n\nDifferent to proof of work type blockchain such as Bitcoin, CENNZnet uses proof of stake to reach consensus and secure the network, which encourages participation and reduces energy consumption. On CENNZnet, user stakes CENNZ to run a node as validator. Validator participates in block production and validation, and receives the CentraPay token as a reward. CentraPay token is a utility token for paying transaction fees on CENNZnet. The CentraPay token is designed to be less volatile and more predictable, with a goal to power activities on CENNZnet. With the dual token model, CENNZnet aims to correlate the value of CENNZ with network activity, while keeping fees stable and reasonable for continue network growth. You can read more about this process in monetary policy. \n\nUnlike Ethereum, where ether is the native token and all others (such as ERC20) are second class assets, CENNZnet's Generic Asset protocol allows various assets to be managed and operated natively. For example, on CENNZnet it becomes very easy to manage all assets for a given account and it also allows users to pay transactions fees in any assets traded in the CENNZX spot exchange. \n\nCENNZnet consists of a series of protocols and services that are fundamental for building any commercial-grade applications, such as single-sign on, exchange, communication, storage, token generation, attestation (and KYC services powered by it) etc. \n"},{"topic":"CENNZNet","path":"cennznet.github.io/docs/CENNZNet/overview/consensus.md","text":"Consensus\n\nAs a public blockchain, CENNZnet is designed to allow parties to reach consensus on the changing the state of the blockchain. For example, updating your account balance, without trusting each other, even when there are malicious participates who actively attempt to lie about the state to break the system and/or for financial gains. CENNZnet aims to be highly efficient commercial-grade blockchain, while also striving for a high grade of decentralisation and more individuals can participate in the consensus process. \n\nProof of Stake (PoS)\n\nCENNZnet is a proof of stake chain. Unlike the Bitcoin-like proof of work chain, which uses computing power to secure the network and uses large amounts of energy, proof of stake blockchain uses stake, meaning that value is held by addresses on a node and the Byzantine Fault Tolerant (BFT) algorithm to secure the network. The BFT algorithm requires majority support from participating nodes (known as validators) who will sign votes for the proposed state change. Malicious behaviours and behaviours that do not conform to the protocol, such as voting multiple times, or proposing different states to different nodes (e.g. double spend attempt) would be penalised. Mathematically, the protocol is proven viable as long as more than 2/3 of the nodes in the network are not malicious.\n\nFor Pre-net launch, CENNZnet uses a combination of Aurand/GRANDPA consensus, based upon the BFT algorithm powered by PL^G and Substrate. Aura/GRANDPA (BABE/GRANDPA in the next version) is a hybrid consensus that increases the speed of the blockchain, with fast block production and intermediate finality using Aurand (BABE for next version), while also providing absolute finality in a longer term using GRANDPA. This consensus protocol is subject to review and update.\n"},{"topic":"CENNZNet","path":"cennznet.github.io/docs/CENNZNet/overview/governance.md","text":"Governance (Coming Soon)\n\nCENNZ holders have the right to propose motions for CENNZnet and the voting power to approve or disapprove the motions. Motions are executable on chain, for example, a motion can be a proposal to increase maximum number of validators and upon approval the change will be made on chain automatically after certain cool-down period. \n\nThe proposed motions will be put into a referendum, where your voting power is determined by the CENNZ bonded to the proposal and the duration you are willing to lock those CENNZ upon winning. A cool-down period, during which winning voters' CENNZ are locked before a motion, is enacted can avoid irresponsible votes carrying bad proposals.\n\nThe council is a delegated group for decision making. Anyone with CENNZ can bond their CENNZ and be elected as council member for a certain period of time. \n\nMore details are coming soon as we finalise the governance process. \n"},{"topic":"CENNZNet","path":"cennznet.github.io/docs/CENNZNet/overview/monetarypolicy.md","text":"Monetary Policy\n\nPrinciples\n\nBelow are the principles for the CENNZnet economy design\n\nReduce friction for on-boarding dApps and users\n\nEnsuring that it is cost efficient to run applications\n\nCENNZ value appreciates as network usage increases\n\nEncourage and incentivise good applications to grow on CENNZnet\n\nGoverned by people who have stake in CENNZnet\n\nDual Token Economy\n\nCENNZnet is designed to be a dual token economy with staking token (CENNZ) and spending token (CentraPay). Application builders and developers want predictable costs to understand how to make a profit. At the same time you want to optimise usage of the network and prevent attacks. CENNZNet's dual token economy attempts to achieve predictable costs and optimal usage. \n\nCENNZ (the staking token) is required as stake for participating in the proof of stake (PoS) consensus as a validator and governance of CENNZnet. It is a store of value token. The increase in the value of CENNZ would correlate with increase in network utilisation. Investors are incentivised to hold their CENNZ, and stake CENNZ to support network growth and earn block rewards at the same time.\n\nCentraPay (the spending token) is the utility token that is used to pay for transaction fees and as reward to validators. It is a medium of exchange token. CentraPay is designed to be stable and predictable, with a goal to power activities on CENNZnet. Users are incentivised to use CentraPay within the network, increasing its velocity and helping with network growth.  \n\nStaking Token: CENNZ\n\nIn January 2018, 1,200,000,000 CENNZ were issued on Ethereum as ERC20 tokens through Centrality's token generating event. This number is finite and there will be no more CENNZ issued. Prior to the CENNZnet mainnet launch, a mechanism will be provided to transfer CENNZ in ERC20 token into CENNZnet. More details will be provided soon. \n\nDenominations\n\n\n\nSpending Token: CentraPay (CPAY in short)\n\nValidators will stake CENNZ to participate in CENNZNet consensus, and earn rewards in CentraPay token. CentraPay is also the utility/spending token for paying transaction fees on CENNZNet. The value of CENNZ is expeced to increase as network usage increases, while CentraPay is designed as medium of exchange and its value would be relatively stable with slight inflation and predicatable to support network growth. The CentraPay token is minted during each reward cycle and distributed to validators who have participated in the cycle. Issuance of CentraPay is not capped. It is designed to be stablised against in-chain purchasing power (measured in standard sized transaction) and off-chain purchaing power (measured in units of computing). New CentraPay tokens are minted based on a mint multiplier times the number of tokens burnt. This mint multiplier is dynamically adjusted for network activity while taking into account of number of validators in order to keep the value of CentraPay stable with slight inflation, while providing enough incentive for validators. \n\nThis model is subject to community feedback and change proposal. \n\nRefer to the Issuance of Spend Economics Paper for more details.\n\nDenominations\n\n\n\nReserve Tokens\n\nApplications like Sylo and SingleSource have special permissions and token economy in our ecosystem, and is implemented at the core protocol runtime layer. Going forward our community would be able to choose and promote an application into this special domain. These applications may have their own tokens (as reserve token) to realise special previliages.\n\nUser Tokens\n\nUsers can create their own token in ERC20 fashion. More details will be provided in this area later. \n\nRefer to Generic Asset in the Protocols page for implementation details of various tokens on CENNZNet. \n"},{"topic":"CENNZNet","path":"cennznet.github.io/docs/CENNZNet/overview/nodes.md","text":"Nodes\n\nA full node maintains the data from a blockchain, which is important for chain security. A full node would synchronise the chain data and verify the new signatures and transaction fees before broadcasting transactions to the network. People may want to maintain their full node as a trusted data source and for performance reasons for their applications. Developers may spin up their own full node, or use the UNfrastructure service (CENNZNet node in the cloud) for decentralised application development. Another example is UNcover which maintains its own full nodes as data source for data mining and serving services, like block explorer.\n\nValidator Node\n\nA validator node is a full node that participates in the validation and consensus process - it executes the chain business logic, producing new blocks and validating transactions. To turn a full node into a validator node, the blockchain data needs to be fully synchronised to the node and a staking account key needs to be provided to the node for staking fund management. \n\nA full node runs the CENNZnet-node WebAssembly runtime program (in Rust). You can run a node to connect to CENNZnet network, or locally using the docker image of an implementation, or using the node software, rUN, with its friendly user interface available on Mac, Windows and Linux download here.\n"},{"topic":"CENNZNet","path":"cennznet.github.io/docs/CENNZNet/overview/protocols.md","text":"CENNZnet Protocols\n\nCENNZnet protocols are built-in runtime modules that define the behaviours of the CENNZnet blockchain. These protocols (as runtime modules) define what data is stored on the chain, how transactions are interpreted and how state transitions are performed. The protocols can interact with each other collectively create the business logic layer of CENNZnet.   \n\nThis is different to smart contracts on CENNZnet. Anyone can deploy a smart contract to execute business logic, but it does not impact the in-chain behaviour of CENNZnet and it is executed in a sandbox environment to protect the network. \n\nCENNZnet is released with a set of protocols that are designed to maximise usability and bootstrapping ability of decentralised applications. These protocols are proposed and documented in the form of a CENNZnet Improvement Proposal (CIP), which are solicited and approved by the community. In the future, the approval of protocols can be incorporated into on-chain governance.\n\nGeneric Asset \n\nAttestation \n\nSingle Sign On \n\nSpot Exchange \n\nGeneric Asset \n\nGeneric Asset protocols enables CENNZnet's dual token economy and enables assets being managed and operated natively. Generic Asset protocol defines varied asset types, their properties and operations.\n\n\n\nCENNZ is the staking token on CENNZnet. CentraPay is the spending token on CENNZnet for paying transaction fees. Refer to staking for more details on staking mechanisms on CENNZNet. Refer to monetary consensus for details of CENNZ as staking token, issuance of CentraPay and how to get CentraPay.\n\nReserve tokens are tokens required by CENNZnet protocols. Not every protocol requires a token to operate. For example, a Generic Asset does not require an economic model to function, hence there is no token associated with it. However, for protocol that has a token model, reserve tokens are used to manage issuance and permission etc. For example, CENNZnet is released with a communication protocol powered by Sylo and uses the SYLO token to power this service. Again a CIP is required with community support and approval before a reserve token can be created.\n\nUser tokens can be created by anyone. Future release will support a smart contract standard for token implementation.\n\nFor more details on the CENNZnet token economy, please refer to monetary consensus\n\nFor more details of Generic Asset protocol and specification, please refer to GA repo.\n\nRefer to Generic Asset SDK repo on how to manage and transfer assets. \n\nAttestation \n\nAn increasing number of organisations want to reduce the cost of verifying attributes of their customers and the risk of holding their personal information.  The Attestation protocol provides an on-chain claim registry that aims to make sharing attested identity claims simple and cost efficient. \n\nThe protocol provides a registry that holds claims that are made by an issuer (an address) about a holder (an address) regarding a topic (e.g. a passport document) with a value, which could be a hash of an off-chain attestation document. This makes it possible to verify the document was indeed attested and signed by the issuer without exposing the user's personal identifiable information. \n\nRefer to Attestation protocol repo for more details.\n\nRefer to Attestation SDK on how to add claims, remove claims and query claims. \n\nReference Implementation\n\nThe SingleSource service is an issuer implementation and mySingleSource app is an holder implementation link. \nThe 18+ app is a demo app that showcases the usage of the entire protocol.\n\nSingle Sign On / Permission \n\nSingleSource wallet App & SingleSource Extension\n\nThe SingleSource wallet App manages your private key and accounts on your device and can be used as a signer for logging into CENNZnet web applications and authoring transactions. The SingleSource web extension can be easily incorporated into any web application to enable this experience. For example, CENNZX Spot excahnge site will integrate with the SingleSource web extension, to enable user seamlessly accessing their SingleSource wallet accounts, and prompts users with QR code to sign with their SingleSource Wallet App when an exchange transaction needs to be signed.\n\nRefer to the SingleSource Extension Doc for more details.\n\nMySingleSource Wallet App (Rimu testnet version) can be downloaded from TestFlight.\n\nSingleSource Extension can be installed from Chrome Webstore.\n\nRefer to SingleSource Extension Repo for more details on incorporating the extension to your web application. \n\nCommunication\n\nComing soon...\n\nSpot Exchange \n\nThe CENNZX Spot enables seamless fee payment experience on CENNZnet and makes token exchange instant and easy. The CENNZX Spot eliminates rent extraction and centralised services, while prioritising decentralisation, usability and security.\n\nCENNZX Spot vs Order Book Exchange\n\nUnlike the order book trading exchange model, where there are buy orders and sell orders and the exchange matches up both sides for a trade, CENNZX Spot uses on-chain reserve with automatic pricing and allows users trade directly against its protocol, rather than other traders or market makers. \n\nAs market maker (or liquidity provider) on an order book exchange, you maintain a spread between two assets and slowly accumulate profits, but this usually requires you to have a large amount of initial capital. Whereas on CENNZX Spot, it pulls liquidity from a number of providers, automates pricing and spread and fees are split proportionally to their contribution, hence a much more user friendly and decentralised experience. The protocol does not collect any platform fees. All fees are put back to the pool and collected when liquidity provider exist from the pool. \n\nPrice Determination\n\nFor price determination, it uses constant product market maker, where you lock up reserves of two assets - in CENNZnet it's always CentraPay and one other asset. The protocol keeps the product of two assets constant. For example, if a liquidity provider locks up an initial 1000 CentraPay and 10 CENNZ, then the product 1000x10=10,000 is always kept constant (technically the constant grows slightly as fees get put back to the pool after each trade). This means the price is based of the ratio of the two assets and is set by arbitragers. \n\nHow to Trade\n\nA user can exchange either direction of the CentraPay-Asset pair (via assetToCoreSwap and coreToAssetSwap methods); the user can also exchange either direction of the asset-asset pair, provided the CentraPay-Asset pools exist for both assets (via assetToAssetSwap method). If an asset does not yet have an exchange, it can be created and liquidity can be added via the protocol method addLiquidity. Liquidity providers are required to deposit equivalent value of both CentraPay and relevant asset into the exchange pool.\n\nRich Exchange Scenario\n\nTrading in the CENNZX Spot generally revolves around two paradigms:\n1\\. A user wants to sell asset on the exchange (input), or\n2\\. A user wants to buy asset from the exchange (output)\n\nWhen a user is selling, the protocol frequently refers to this as input.\nIn this case, the user must also give a minimum amount they are willing to accept for the sale.\n\nWhen a user is buying an asset this is often referred to as output.\nThe user must give a maximum amount they're willing to pay for the assets requested.\n\nTrading Fee\n\nA fee of 0.3% is charged for trading between CentraPay-Asset pair or vice-a-versa. For a Cennz->CentraPay trade, 0.3% fee in Cennz is paid. For CentraPay->Cennz trade, 0.3% fee in CentraPay is paid. All fees are put back to the pool. Based on the liquidity provider's contribution to the pool, the fees are distributed among them. \n\nPaying a Merchant in a Different Asset\n\nApart from exchanging between assets, another common use case is when users need to pay others e.g. merchants in an asset they don't have. With CENNZX Spot you can achieve both in one atomic transaction by specifying recipient address and assets to exchange (via assetToAssetTransfer, assetToCoreTransfer and coreToAssetTransfer).  \n\nSeamless Fee Payment\n\nTransaction fees can be paid in any asset, provided there's liquidity in the CENNZX Spot. Exchange will then seamlessly convert the asset into CentraPay for fees. This will streamline both onboarding and in-app experience by eliminating the need for learning about and obtaining the fee token. \n\nThe CENNZX Spot is inspired by the Uniswap protocol, for more details please refer to the CENNZX Spot protocol repo.\n\nRefer to the CENNZX Spot SDK to start using it.\n\nSmart Contract\n\nRefer to the SpinToWin tutorial to build and deploy a smart contract in an hour. \n"},{"topic":"CENNZNet","path":"cennznet.github.io/docs/CENNZNet/overview/staking.md","text":"Staking\n\nStaking is the process of locking up CENNZ (as the stake) to participate in maintaining the security and integrity of the network, and to gain reward as a result. There is also a risk of being slashed if you are found to be demonstrating malicious behaviour or not fulfilling the promise of a good and honest maintainer. \n\nThere are two ways to participate in securing the network, as a validator or as a norminator. A validator runs a node, participates in producing blocks, validating transactions and guaranteeing finality of the chain. A norminator does not need to run a node, but stakes towards one or more of the validators at their choice. Essentially, validators have a pool of staking funds from themselves and from norminators. Both validators and norminators will earn rewards in CentraPay token proportional to their stake. Because Validators provide critical services to the network, they have certain privilege regarding payment preferences e.g. they can decide how much reward they would keep before distributed pro rata amongst all stakers in their pool. \n\nThere are three accounts namely Stash, Controller and Session to manage funds in staking. Separate account management allows using cold wallet to manage funds to improve security, and enables switching between validator,  norminator and idle mode (not staking) easily.\n\nStash Account (holds funds for staking)\n\nStash account is the primary account for holding funds for staking. This could be a cold wallet. Users could specify the amount in the Stash account used for staking, and this amount will be bonded meaning locked up as stake. This amount will then be under control of the associated Controller account for staking operations. Upon being unbonded, user needs to wait for a certain period of time (bonding duration) before the funds can be withdrawn.\n\nController Account\n\nController account manages the staked (bonded) funds, and staking status e.g. switching from validator to norminator or idle (not staking). The Controller account will need to have enough balance when sending these transactions. \n\nSession Account\n\nThe Session account is used for the node running by the validator. It is recommended to use a different keypair for Session account than the Controller account so that even if the node is compromised, the funds would not be stolen. The seed of the Session account is passed to the node using the --key parameter. No balance is required for this account.\n\nReward\n\nReward is calculated each session, and distributed to validators upon a new era starts. A session is a set number of blocks; and an era is a set number of sessions. These numbers can be changed for performance reasons or other reasons via a gonvernance process. The reward is paid in spending tokens (CentraPay). The amount of CentraPay minted for reward is adjusted based on network activity with the goal to stablise and be reasonable for the cost of running the network. You can read more of the issuance mechanism in this Issuance of Spend Economics Paper.  \n\nValidator can choose to keep a certain amount of reward before paying out to its norminators. Both validators and norminators can choose from one of these reward destination: Controller account, Stash account and increase staked amount, and Stash account but not increase staked amount. \n\nSlashing / Punishment\n\nIf a validator is reported to be offline, its bonded balance in Stash account would be reduced first, and if that runs out the norminator's balances would be reduced. The network allows for a grace period (offline slash grace). Validators can also set a threshold of the maximum number of times they are slashed before its validator status being removed (unstake threshold). Essentially a validator can be offline offline slash grace + unstake threshold number of times, before they are forced to unstake. \n\nCENNZNet Validator Pool\n\nFor Prenet period, there is maximum number of validators allowed in the CENNZNet network, and there is a minimum number of validators required to ensure network security. If there are more validators intending to join the network than the maximum number allowed, then they will be on a wait list. Validators are re-selected every staking period (e.g. every era) - the top x number of validators based on staking amount would be selected into next round of staking period. In addition, there will be a minimum staking amount required to join the validator pool - it needs to be high enough to add another layer of security to the network, but low enough to promote participation on CENNZnet. Again these parameters can be changed later via governance process. \n"},{"topic":"CENNZNet","path":"cennznet.github.io/docs/CENNZNet/overview/transactions.md","text":"Transactions\n\nA transaction on CENNZnet is a signed data package that contains a message sent from an account to a node, which is then broadcast to the network. The message could be for value transfer from one account to another, or it could be an operation that an account wants to perform on chain. For example exchanging one asset to another via CENNZX. \n\nCENNZnet transaction is based on substrate extrinsic with additional CENNZnet specific properties.\n\nTransaction Format\n\nTransaction includes\n\nA version byte indicate the format version\n\nAn operation descriptor that specifies the protocol (module), the method and inputs for the operation.\n\nFor example, to transfer 10 CENNZ from accountA to accountB, you would specify the protocol as Generic Asset, the method as transfer and input as accountB for amount of 10 in CENNZ asset. \n\nA nonce value to prevent replay attack.\n\nAn optional transaction era to limit the lifetime of this transaction.\n\nAn optional permission document.\n\nAn optional CENNZX operation to allow fees to be paid in any of the supported tokens.\n\nA signature signed by the transition creator covers all the above payload.\n\nTODO link to extrinsic format \nRefer to CENNZnet-js for creating and sending transactions.\n\nTransaction Fee\n\nCENNZnet is a network of participating nodes that runs the CENNZnet-node WebAssembly runtime (aka the CENNZnet business logic). Transactions are broadcasted and saved by every node on the network. This has a cost, which can be measured in resource units and on CENNZnet it can be expressed as a spend token (aka CentraPay as transaction fee). \n\nThe purpose of transaction fee is to ensure the sender pays for at least the cost for the network to process this transaction. It also acts as a security gateway to ensure the cost to spam the network is high.\n\nTransaction fee is the total amount of fee deducted from signer account in order to have the transaction included in the confirming block. This includes transaction payment as well as any other addition fees.\n\nTransaction payment is strictly the minimal payment required for the inclusion of the transaction on-chain to be valid, i.e. to not panic. Once the transaction is included on-chain it must be dispatched. (link to substrate doc) (original source: https&#x3A;//github.com/paritytech/substrate/issues/1993#issuecomment-472815054)\n\nTransactionPayment = BaseFee + ByteFee \\* TransactionByteSize\n\nTransactionFee = TransactionPayment + AdditionalFee\n\nAdditional fee may also be charged ensures the resource usage (CPU & storage) for the transaction is direct proportional the total fee charged. Example of additional fees are transfer fee charged by generic asset transfer method, and gas fee charged by of smart contract invocation.\n\nTODO link to fee module spec\n\nThe transaction fee model is under review and subject to change. \n"},{"topic":"CENNZNet","path":"cennznet.github.io/docs/CENNZNet/roadmap.md","text":"CENNZNet Roadmap\n\n\n"},{"topic":"CENNZNet","path":"cennznet.github.io/docs/CENNZNet/toolkit/cli.md","text":"Command Line Tool (CLI)\n\nThe command line tool allows you to connect to, interact with and run your application on CENNZNet blockchain easily. It uses and depends on the CENNZNet SDK.\n\nFor more details please refer to CLI repo.\n"},{"topic":"CENNZNet","path":"cennznet.github.io/docs/CENNZNet/toolkit/explorer.md","text":"Explorers\n\nExplorers are tools that you explore and search the blockchain for transactions, accounts, assets and other activities on chain.\n\nUNcover\n\nStart your journey with exploring blockchain in an easy way!        \n\nPacked with human-readable data\n\nMost block explorers are full of data which is confusing at first, especially when you are new to blockchain space.\nTo reduce the cognitive bias we made an effort to present the data in a format that most of us is already familiar with.\nYou will see information in high level fashion, tabulated with just highlights of important stuff, as well as drilled down to more detailed overview.\nWhat is really cool though is the overview with banking-like look & feel - where transactions and events are presented in a logical and understandable manner.\n\nMany uses\n\nObserve blocks as they come in (near) real-time fashion.\nGo back and forth in time with tracking transactions, asset allocations and transfers as well as balances for any account.\nPlug your DApp and track smart contract (runtime module) execution and outcomes.\nCheck stats and visualizations to better understand\nAny many more!\n\nWhere to begin\n\nFor block explorer webpage visit www.uncoverexplorer.com\nFor API access check API documentation \n\n\n"},{"topic":"CENNZNet","path":"cennznet.github.io/docs/CENNZNet/toolkit/nodeincloud.md","text":"Node In the Cloud\n\nCENNZNet Infrastructure (UNfrastructure) provides load-balanced nodes in the cloud service for seamless CENNZNet access without the need of running your own nodes e.g. for development. The UNfrastructure provides JSON-RPC over Websocket and HTTPS APIs for subscribing to CENNZNet blockchain events. Learn more about Unfrastructure API and start a new project now, got the unfrastructure.io.\n"},{"topic":"CENNZNet","path":"cennznet.github.io/docs/CENNZNet/toolkit/nodesoftware.md","text":"Node Software\n\nNode Software makes it really easy for anyone to set up an account, manage their assets and wallet, rUN a node and participate as a Validator on CENNZNet via a simple and intuitive user interface. You can download the rUN a Node Software via runanode.io. Refer to our repo for more details.\n\nYou can find series of tutorial/article to help you rUN a node.\n\nQuick start guide\n\nStaking on CENNZNet\n\nExample for some of our pages:\n\n\n\n\n\n\n\n\n\nStaking management\n"},{"topic":"CENNZNet","path":"cennznet.github.io/docs/CENNZNet/toolkit/sdk.md","text":"CENNZNet SDK\n\nWhile there are extensive JSON-RPC API endpoints available to interact with CENNZNet directly, the CENNZNet SDK library set is designed to take care of the underlying plumbing and allow developers easily interact with and build on CENNZNet, as well as leveraging its protocols. The library set is written in javascript, it is derived and extended from Plugnet SDK library, which is a fork and extension of the polkadot.js. Below are select few features of the CENNZNet SDK: \n\nHandles binary format encoding and decoding of transactions that interact with CENNZNet protocols and smart contracts\n\nProvides support for creating and managing accounts, signing transactions, broadcasting transactions and basic fee estimation\n\nProvides a HD wallet implementation that can be easily used and extended for dApps\n\nThe following tables are the SDK libraries available, and will be updated as new protocols or libraries been made available.\n\n\n"},{"topic":"CENNZNet","path":"cennznet.github.io/docs/CENNZNet/toolkit/tests.md","text":"Tests\n\nTests for various aspects of CENNZNet. This repos would be updated regularly with new tests.\n\nBlockchain tests\n\nThese tests provide basic verification of CENNZNet. It covers scenarios from running a node to using CENNZNet protocols  including Generic Asset (e.g. fees and transfer operations), Attestation, and CENNZX etc. Refer cennznet-tests for more details.  \n\nPerformance tests\n\nThese tests are used to assess the basic performance of CENNZNet nodes under various circumstances, which will serve as benchmark for continuous improvement in this space. There are latency tests, single node and multi node tests. Refer performance-tests for more details.\n"},{"topic":"CENNZNet","path":"cennznet.github.io/docs/CENNZNet/toolkit/wallet.md","text":"Wallet\n\nCentrapay Wallet is a portfolio of wallet and payment gateway libraries that makes account (private key) management and value transfer seamless in CENNZNet ecosystem.\n\nwallet SDK\n\nThe wallet SDK provides methods to create password protected HD wallet to manage multiple keys, backup and restore a wallet, backup and import an account, lock and unlock a wallet etc. Refer to the wallet repo\n\nSingleSource Wallet\n\nMySingleSource Wallet App contains a HD wallet that manages your keys and funds on CENNZNet. Using in conjunction with the SingleSource Extension, it is also a signer/authenticator for authoring transactions and interactions with CENNZNet initiated by any web applications. \n\nMySingleSource Wallet App (Rimu testnet version) can be downloaded from TestFlight.\n\nSingleSource Extension can be installed from Chrome Webstore.\n\nRefer to SingleSource Extension Repo for more details on incorporating the extension to your web application. \n\nSylo Wallet\n\nComing soon...\n"},{"topic":"CENNZNet","path":"cennznet.github.io/docs/CENNZNet/toolkit/webui.md","text":"\\#Web UI\nComing soon\n"},{"topic":"CENNZNet","path":"cennznet.github.io/docs/CENNZNet/tutorials/sample_dapps.md","text":"dApps\n\nSpin2Win dApp on Rimu Testnet\n\nDownload the App via https&#x3A;//testflight.apple.com/join/fm119AW0\nVideo demo?\n\n18+ dApp on Rimu Testnet\n\nDownload the App via https&#x3A;//testflight.apple.com/join/otbNZE0H\nVideo demo?\n\nSingleSource dAPp on Rimu Testnet\n\nDownload the App via link\n"},{"topic":"CENNZNet","path":"cennznet.github.io/docs/CENNZNet/tutorials/sc_getstarted.md","text":"Getting Started\n\nThis guide will help you setup a contract development environment.\nIt involves installing a rust nightly toolchain and a few other bells and whistles.\n\nInstall the Things (Mac + Linux)\n\nRustUp is the defacto version manager for the rust toolchain. We'll use it to setup and configure rust on our system.\n\nIn a terminal run:\n\n\n\nThe installer will place $HOME/.cargo/bin onto your path environment variable. This will take affect on your next login but because you probably want to get going, you can prefix your current path by running:\n\n\n\nAdd the web assembly compilation target\n\n\n\nWe also need a special wasm processing tool (wasm-build).\nIt optimizes compiled wasm for running on Substrate based blockchains.\n\n\n\nNext install cargo generate, a useful subcommand to make new cargo project's from existing git repositories.\n\n‚òï time! this may take ~10 mins\n\n\n\nThat's it! you're all set to develop smart contracts for CENNZnet.\n\nInstall the things (Windows)\n\nThe most straight forward option is to user docker to setup our development environment  \n\nDownload and install docker from https&#x3A;//runnable.com/docker/install-docker-on-windows-10\n\nOpen docker settings, choose shared drives and select your C: drive as shared.\n\nRun a rust nightly docker container\n\n\n\nRun a shell session in the container\n\n\n\nOpen the /shared folder in your IDE. We'll use this as the workspace for contract development.\nIt is shared between the docker contrainer (build environment) and your host OS.  \n\nAll done :D\nThis docker environment is capable of building contracts  \n"},{"topic":"CENNZNet","path":"cennznet.github.io/docs/CENNZNet/tutorials/spin2win.md","text":"Spin2Win Contract\n\nOverview\n\nIn this tutorial you'll learn how to design, build, deploy and call a smart contract on a CENNZnet blockchain.\n\nWe make a few assumptions before getting started.  \n\nYou're using macOS, GNU/Linux, or similar UNIX-based system  \n\nYou have some programming experience  \n\nThe contract we'll be creating is a simple casino game Spin2Win.  \n\nYou know the game where you spin a wheel and win a prize\ndepending on where it stops?\n\n\n\nAll we need is a player account to send winnings to and a random\nvalue to simulate the wheel spin.\n\nYou can follow along with the final code here.\n\nGetting Started\n\nFirst check you have followed these guides:\n\nInstall rust and the contract build toolchain.\n\nSetup and run a local CENNZnet node\n\nOnce all that is done we can create a new contract project using the template repo\n\n\n\nThe newly created project should have the following content in src/lib.rs\nGo ahead and rename the struct Demo and its usages with Spin2Win instead.\n\n\n\nSmart Contracts?\n\nIn a nut-shell a CENNZnet smart contract is some stored web assembly code with an associated account on chain.\nIt can use blockchain storage and interact with runtime functionality.  \n\nIn general, any network user can invoke a smart contract provided they pay a fee (AKA gas) for the computational resources used e.g. CPU, storage, network, etc.  \n\nCENNZnet contracts are written in rust and cross-compiled to wasm. Parity (Substrate) provide a DSL to make this simpler, Ink.  \n\nWe'll be using Ink to bootstrap the majority of our contract code.\nFor reference it ships with 3 different APIs: core, model, and lang:  \n\nlang gives the highest level of abstraction and hides the most complexity.  \n\ncore provides the least abstraction and requires more knowledge of the underlying workings of the contract virtual machine.  \n\nmodel is somewhere in between the two  \n\nDesign\n\nBefore we get started with implementation, our contract at a glance should:\n1\\. Define a public function which receives an account ID of a player\n2\\. Generate a random value of winnings\n3\\. Transfer winnings to the player's account  \n\nWriting the Contract üìÑ\n\nWe'll use the contract! macro from the ink_lang crate to stub out the basic structure of the contract.\nIt requires us to define a struct for the contract's data and an impl block to define its available function calls.\n\nIn this case, our contract design doesn't require us to store any data so we can leave the definition empty ({}).\nThe interesting part of our contract will all be contained in a single public call, which users can invoke to play the game.\nLet's add that in now.\n\n\n\nYou'll notice we imported the contract_sdk crate. It provides bindings for CENNZnet types and some other useful functions missing from ink.  \n\nSpinning the Wheel üîÅ\n\nIRL spinning a wheel and the value it stops on are seemingly unpredictable.\nTo simulate this we need a random value to use when calculating how much our player should win.\n\nThe Substrate runtime provides a random 32 byte sequence derived from the previous block. This is accessible to contract's via the contract SDK with  Context::random_seed().  \n\nHowever, for our use case we want a single integer. The contract SDK provides a nice utility function for this exact case, wrapping Context::random_seed().\n\nWe can ask for an integer in a given range, thereby setting a lower and upper limit on a player's potential winnings.\n\n\n\nPaying the Player üíµ\n\nThe last step is to transfer the winnings to the player.\nThe functionality to do this directly is missing (read complicated) at the moment.\nHowever, we can accomplish it indirectly by executing a dummy call to the player's account, as a side affect transferring some value (prize money).\nWe can invoke a call using the contract_sdk crate and it's provided Runtime binding.  \n\n\n\nThat's the implementation finished. Check your contract matches up with this one before trying the next section.\n\nBuilding the Contract üõ†Ô∏è\n\nRun the following command to build the contract\n\n\n\nThis will output built artefacts in ./target, primarily,  \n\nspin2win.wasm\nThe ready to deploy contract binary  \n\nSpin2Win.json\nThe contract's ABI metadata for client code generation  \n\nThe other files are various intermediate outputs and representations which maybe useful for debugging.\n\nDeploy the Contract\n\nA contract is deployed in two steps, the first is a putCode operation where the binary is stored on chain.\nThe second part is where the stored contract is instantiated, any one-time setup operations are performed and the contract's address is generated.  \n\nOpen a web browser to the CENNZnet UI and check it's connected to your local node.\nLocal Node: (127.0.0.1:9944) should be selected in the endpoints dropdown.\n\n\nHit \"save & reload\" to apply the changes.\n\nWith that configured we can go to the contracts view.\n\nThis is where we can deploy, instantiate, and call smart contracts.\nRecall that each of these operations requires some gas payment in exchange.  \n\nTo deploy the contract select a user account\\* from the dropdown and choose the spin2win.wasm and Spin2Win.json ABI files like so.   \n\n\\*Note: On a development chain pre-created accounts are available e.g. Alice, Bob, Charlie  \n\n\n\nClick \"Deploy\" and follow the prompt to sign and submit the transaction.\n\nYou'll see the following events raised\n\nThis means the transaction was succesful and the contract code has been stored on the chain.\nUse the explorer view to see the block transactions and events in more detail.\n\n\n\n\nNext we'll instantiate the contract. The view should have automatically switched over to \"Instance\".\n\nAs part of this we can give the contract an initial endowment balance,\nthis will act as the prize pot for player winnings. It can be topped up anytime by transferring more balance into the contract.  \n\n\n\nYou should receive event notifications matching\n  \n\nCall the Contract üìû\n\nAfter all that hard work we can call the contract!\nNotice the UI has used our contract's ABI and created a form with the 'spin' public function and correct data type, neat huh?  \n\nAll we need to do is select a player to spin the wheel, some value and gas fees to play.\n  \n\nIf all goes well you'll see the following events\n  \n\nThere are two contract.Transfer events. One is the entry fee from the player to the contract while the other is\nwinnings going from the contract to the player.\n\nYou can dig into the block events through the explorer to see exactly how much was won.\n\nEpilogue üéâ\n\nYou just learned how to write a smart contract for CENNZnet end-to-end!\n\nIf you're interested in learning more, there are some changes that could be made to improve the contract:  \n\nCurrently users can pay any amount to play (value). Add a check to ensure the value is above some reasonable amount say, 100  \n\nWe may want to rate limit how often people can call the contract e.g. per day or per n blocks.\nTry adding a Map structure in contract storage and use this to track callers\n\nYou may have noticed that the RNG seed will be the same each block so if multiple people call the contract in a block they will win the same amount.\nOne way to fix this is to involve the player account ID (e.g. XOR) when calculating the random amount.\nTry modifying the winnings amount use Context::random_seed() directly.  \n"}]